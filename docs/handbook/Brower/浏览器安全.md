<!-- 解析语雀图片 -->
<meta name="referrer" content="no-referrer" />

# 浏览器安全

## XSS （Cross-Site Script 跨站脚本攻击 ）

### 什么是XSS攻击？

- XSS攻击指的是跨站脚本攻击，是一种代码注入攻击。攻击者通过在网站注入恶意脚本，使之在用户的浏览器上运行
- XSS攻击的本质是因为网站没有对恶意代码进行过滤，恶意代码与正常的代码混合在一起，浏览器无法分辨哪些脚本是可信的，从而导致了恶意代码的运行
- 攻击者可以通过XSS攻击进行以下操作 
   - 获取页面数据，DOM、cookie、localStorage等，之后利用cookie去做一些操作
   - DDOS攻击，发送合理请求，占用服务器资源，进而使用户无法访问服务器
   - 破坏页面结构
   - 导航到第三方网站从而进行流量劫持

### XSS攻击的类型
![截屏2022-05-13 上午11.42.47.png](https://cdn.nlark.com/yuque/0/2022/png/1645656/1652413372847-7142b08c-dc61-43ee-8f45-7408595ce3b6.png#clientId=uf2089c89-8ac9-4&crop=0&crop=0&crop=1&crop=1&from=drop&id=u21586f96&margin=%5Bobject%20Object%5D&name=%E6%88%AA%E5%B1%8F2022-05-13%20%E4%B8%8A%E5%8D%8811.42.47.png&originHeight=680&originWidth=1934&originalType=binary&ratio=1&rotation=0&showTitle=false&size=219768&status=done&style=none&taskId=u59e29e94-3ca4-447e-b291-61c9c67e893&title=)

- 反射型XSS和存储型XSS的区别是 ： 存储型XSS的恶意代码存储在数据库里，反射型的XSS恶意代码存储在URL里
- DOM型XSS和 反射型XSS、存储型XSS 的区别 ：DOM型XSS攻击中，取出和执行代码由浏览器端完成，属于前端自身的安全漏洞，而其他两种XSS都属于服务端的安全漏洞。
### 如何防御XSS攻击
#### XSS攻击两大要素 

   - 攻击者提交恶意代码 
      - 前端过滤用户输入再提交到后端，不可行。一旦攻击前端过滤，直接构造请求，就可以直接提交恶意代码了
      - 后端中写入数据库前，对数据进行过滤，然后把“安全的“的内容返回给前端，不可行。会引发乱码问题 
         - 输入过滤能够中某些情况下解决特定的XSS问题但会引入很大的不确定性和乱码问题
   - 浏览器执行恶意代码 
      - 防止HTML中出现注入
      - 防止JS执行时，执行恶意代码
#### 预防存储型和反射型XSS攻击 

   - 这两种XSS攻击都是从服务端取出恶意代码后，插入到HTML里的，攻击者刻意编写的 数据 被内嵌到 代码中，被浏览器所执行 
      - 纯前端渲染，把代码和数据分隔开（还需避免DOM型XSS） 
         - 浏览器先加载一个静态HTML，此HTML中不包括任何和业务相关的数据
         - 然后浏览器执行HTML中的JS
         - JS通过Ajax加载业务数据，调用DOM API更新到页面上（明确告诉浏览器，要设置的内容是什么，是文本、是属性或者是样式，这样浏览器就不会执行预期以外的操作了）
      - 对插入到HTML中的代码做充分转义
#### 预防DOM型XSS攻击 

   - DOM 型 XSS 攻击，实际上就是网站前端 JavaScript 代码本身不够严谨，把不可信的数据当作代码执行了 
      - 在使用 `.innerHTML`、`.outerHTML`、`document.write()` 时要特别小心，不要把不可信的数据作为 HTML 插到页面上，而应尽量使用 `.textContent`、`.setAttribute()` 等
      - 如果用 Vue/React 技术栈，并且不使用 `v-html`/`dangerouslySetInnerHTML` 功能，就在前端 render 阶段避免 `innerHTML`、`outerHTML` 的 XSS 隐患。
      - DOM 中的内联事件监听器，如 `location`、`onclick`、`onerror`、`onload`、`onmouseover` 等，`<a>` 标签的 `href` 属性，JavaScript 的 `eval()`、`setTimeout()`、`setInterval()` 等，都能把字符串作为代码运行。如果不可信的数据拼接到字符串中传递给这些 API，很容易产生安全隐患，请务必避免
#### 使用CSP，CSP本质是建立一个白名单，告诉浏览器哪些外部资源可以加载和执行，从而防止恶意代码的注入攻击 

   - 开启CSP：设置HTTP首部中的 Content- Security-Policy，设置meta标签 < meta http-equip = '' Content- Security-Policy"> 
      - 严格的 CSP 在 XSS 的防范中可以起到以下的作用： 
         - 禁止加载外域代码，防止复杂的攻击逻辑
         - 禁止外域提交，网站被攻击后，用户的数据不会泄露到外域
         - 禁止内联脚本执行（规则较严格，目前发现 GitHub 使用）
         - 禁止未授权的脚本执行（新特性，Google Map 移动版在使用）
         - 合理使用上报可以及时发现 XSS，利于尽快修复问题
#### 其他安全措施 

   - HTTP-only Cookie: 禁止 JavaScript 读取某些敏感 Cookie，攻击者完成 XSS 注入后也无法窃取此 Cookie
   - 验证码：防止脚本冒充用户提交危险操作

## CSRF攻击
### CSRF攻击指的是跨站请求伪造攻击 

   - 攻击者诱导用户进入一个第三方网站，然后该 网站 向 被攻击网站 发送跨站请求
   - 如果用户在攻击网站中保存了登录状态，那么攻击者就可以利用这个登录状态，绕过后台的用户验证，冒充用户向服务器执行一些操作
   - CSRF攻击的本质是 **利用cookie会在同源请求中携带发送给服务器的特点，以此来实现用户的冒充**
### 常见的CSRF攻击 

   - GET类型的CSRF攻击，比如中网站的一个img标签中里构建一个请求，当用户打开这个网站的时候就会自动发起提交
   - POST类型的CSRF攻击，比如构建一个表单，然后隐藏它，当用户进入页面时，自动提交这个表单
   - 链接类型的CSRF攻击，比如中a标签href属性里构建一个请求，然后诱导用户去点击
### 如何防御CSRF攻击 

   - **进行同源检测**，服务器根据http请求头中的origin或者referer信息来判断请求是否为允许访问的站点，从而对请求进行过滤 
      - 当origin或者referer信息都不存在时，直接阻止请求
      - 这种方式的缺点是有些情况referer可以被伪造，同时还会把搜索引擎的链接也给屏蔽了 
         - 因此，一般网站会允许搜索引擎的页面请求，但是相应的页面请求这种请求方式也可能被攻击者给利用
   - **使用CSRF Token进行验证** 
      - 服务器向用户返回一个随机数Token，当网站再次发起请求时，在请求参数中加入服务器端返回的token，然后服务器对这个token进行验证 
         - 这种方法解决了使用cookie单一验证方式时，可能会被冒用的问题
         - 缺点： 
            - 需要给网站中所有请求都添加上token
            - 一般不会只有一个服务器，如果请求经过负载均衡转移到了其他服务器，这个服务器的session没有保留这个token时，就无法验证了。这种情况可以通过改变token的构建方式来解决
   - **对Cookie进行双重验证** 
      - 服务器中用户访问页面时，向请求域名中注入一个Cookie，内容为随机字符串，然后当用户再次向服务器发送请求时，从cookie中取出这个字符串，添加到URL参数中然后服务器通过对cookie中的数据和参数中的数据进行比较，来进行验证 
         - 这种方式利用了攻击者只能利用cookie，但是不能访问获取cookie的特点
         - 这种方式比CSRF Token更加方便，不涉及到分布式访问问题
         - 但如果网站存在XSS漏洞的，那么这种方式会失效
   - **设置cookie属性时设置Samesite，限制cookie不能作为第三方使用**，从而可以避免被攻击者利用 
      - Samesite 
         - 严格模式：cookie中任何情况下都不可能作为第三方Cookie使用
         - 宽松模式：可以被请求是GET的请求，且会发生页面跳转的请求所使用
